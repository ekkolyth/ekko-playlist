// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: auth.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const CleanExpiredSessions = `-- name: CleanExpiredSessions :exec
delete from "session"
where expires_at < now()
`

func (q *Queries) CleanExpiredSessions(ctx context.Context) error {
	_, err := q.db.Exec(ctx, CleanExpiredSessions)
	return err
}

const CreateAPIToken = `-- name: CreateAPIToken :one
insert into "api_tokens" (user_id, name, token_hash, token_prefix, expires_at)
values ($1, $2, $3, $4, $5)
returning id, user_id, name, token_hash, token_prefix, created_at, expires_at, last_used_at
`

type CreateAPITokenParams struct {
	UserID      string             `json:"user_id"`
	Name        string             `json:"name"`
	TokenHash   string             `json:"token_hash"`
	TokenPrefix string             `json:"token_prefix"`
	ExpiresAt   pgtype.Timestamptz `json:"expires_at"`
}

func (q *Queries) CreateAPIToken(ctx context.Context, arg *CreateAPITokenParams) (*ApiToken, error) {
	row := q.db.QueryRow(ctx, CreateAPIToken,
		arg.UserID,
		arg.Name,
		arg.TokenHash,
		arg.TokenPrefix,
		arg.ExpiresAt,
	)
	var i ApiToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.TokenHash,
		&i.TokenPrefix,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.LastUsedAt,
	)
	return &i, err
}

const CreateSession = `-- name: CreateSession :one
insert into "session" (expires_at, token, user_id, ip_address, user_agent)
values ($1, $2, $3, $4, $5)
returning id, expires_at, token, ip_address, user_agent, user_id, created_at, updated_at
`

type CreateSessionParams struct {
	ExpiresAt pgtype.Timestamptz `json:"expires_at"`
	Token     string             `json:"token"`
	UserID    string             `json:"user_id"`
	IpAddress *string            `json:"ip_address"`
	UserAgent *string            `json:"user_agent"`
}

func (q *Queries) CreateSession(ctx context.Context, arg *CreateSessionParams) (*Session, error) {
	row := q.db.QueryRow(ctx, CreateSession,
		arg.ExpiresAt,
		arg.Token,
		arg.UserID,
		arg.IpAddress,
		arg.UserAgent,
	)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.ExpiresAt,
		&i.Token,
		&i.IpAddress,
		&i.UserAgent,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const CreateVerification = `-- name: CreateVerification :one
insert into "verification" (identifier, value, expires_at)
values ($1, $2, $3)
returning id, identifier, value, expires_at, created_at, updated_at
`

type CreateVerificationParams struct {
	Identifier string             `json:"identifier"`
	Value      string             `json:"value"`
	ExpiresAt  pgtype.Timestamptz `json:"expires_at"`
}

func (q *Queries) CreateVerification(ctx context.Context, arg *CreateVerificationParams) (*Verification, error) {
	row := q.db.QueryRow(ctx, CreateVerification, arg.Identifier, arg.Value, arg.ExpiresAt)
	var i Verification
	err := row.Scan(
		&i.ID,
		&i.Identifier,
		&i.Value,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const DeleteAPIToken = `-- name: DeleteAPIToken :exec
delete from "api_tokens"
where id = $1 and user_id = $2
`

type DeleteAPITokenParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID string      `json:"user_id"`
}

func (q *Queries) DeleteAPIToken(ctx context.Context, arg *DeleteAPITokenParams) error {
	_, err := q.db.Exec(ctx, DeleteAPIToken, arg.ID, arg.UserID)
	return err
}

const DeleteSession = `-- name: DeleteSession :exec
delete from "session"
where token = $1
`

func (q *Queries) DeleteSession(ctx context.Context, token string) error {
	_, err := q.db.Exec(ctx, DeleteSession, token)
	return err
}

const DeleteUserSessions = `-- name: DeleteUserSessions :exec
delete from "session"
where user_id = $1
`

func (q *Queries) DeleteUserSessions(ctx context.Context, userID string) error {
	_, err := q.db.Exec(ctx, DeleteUserSessions, userID)
	return err
}

const DeleteVerification = `-- name: DeleteVerification :exec
delete from "verification"
where value = $1
`

func (q *Queries) DeleteVerification(ctx context.Context, value string) error {
	_, err := q.db.Exec(ctx, DeleteVerification, value)
	return err
}

const GetAPITokenByHash = `-- name: GetAPITokenByHash :one
select t.id, t.user_id, t.name, t.token_hash, t.token_prefix, t.created_at, t.expires_at, t.last_used_at, u.email as user_email
from "api_tokens" t
join "user" u on t.user_id = u.id
where t.token_hash = $1
  and (t.expires_at is null or t.expires_at > now())
limit 1
`

type GetAPITokenByHashRow struct {
	ID          pgtype.UUID        `json:"id"`
	UserID      string             `json:"user_id"`
	Name        string             `json:"name"`
	TokenHash   string             `json:"token_hash"`
	TokenPrefix string             `json:"token_prefix"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	ExpiresAt   pgtype.Timestamptz `json:"expires_at"`
	LastUsedAt  pgtype.Timestamptz `json:"last_used_at"`
	UserEmail   string             `json:"user_email"`
}

func (q *Queries) GetAPITokenByHash(ctx context.Context, tokenHash string) (*GetAPITokenByHashRow, error) {
	row := q.db.QueryRow(ctx, GetAPITokenByHash, tokenHash)
	var i GetAPITokenByHashRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.TokenHash,
		&i.TokenPrefix,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.LastUsedAt,
		&i.UserEmail,
	)
	return &i, err
}

const GetSessionByToken = `-- name: GetSessionByToken :one
select s.id, s.expires_at, s.token, s.ip_address, s.user_agent, s.user_id, s.created_at, s.updated_at, u.id as user_id, u.email as user_email
from "session" s
join "user" u on s.user_id = u.id
where s.token = $1
  and s.expires_at > now()
limit 1
`

type GetSessionByTokenRow struct {
	ID        string             `json:"id"`
	ExpiresAt pgtype.Timestamptz `json:"expires_at"`
	Token     string             `json:"token"`
	IpAddress *string            `json:"ip_address"`
	UserAgent *string            `json:"user_agent"`
	UserID    string             `json:"user_id"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
	UserID_2  string             `json:"user_id_2"`
	UserEmail string             `json:"user_email"`
}

func (q *Queries) GetSessionByToken(ctx context.Context, token string) (*GetSessionByTokenRow, error) {
	row := q.db.QueryRow(ctx, GetSessionByToken, token)
	var i GetSessionByTokenRow
	err := row.Scan(
		&i.ID,
		&i.ExpiresAt,
		&i.Token,
		&i.IpAddress,
		&i.UserAgent,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserID_2,
		&i.UserEmail,
	)
	return &i, err
}

const GetUserByEmail = `-- name: GetUserByEmail :one
select id, name, email, email_verified, image, created_at, updated_at
from "user"
where email = $1
limit 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (*User, error) {
	row := q.db.QueryRow(ctx, GetUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.EmailVerified,
		&i.Image,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const GetUserByID = `-- name: GetUserByID :one
select id, name, email, email_verified, image, created_at, updated_at
from "user"
where id = $1
limit 1
`

func (q *Queries) GetUserByID(ctx context.Context, id string) (*User, error) {
	row := q.db.QueryRow(ctx, GetUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.EmailVerified,
		&i.Image,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const GetUserByVerificationToken = `-- name: GetUserByVerificationToken :one
select u.id, u.name, u.email, u.email_verified, u.image, u.created_at, u.updated_at
from "verification" v
join "user" u on v.identifier = u.id::text or v.identifier = u.email
where v.value = $1
  and v.expires_at > now()
limit 1
`

func (q *Queries) GetUserByVerificationToken(ctx context.Context, value string) (*User, error) {
	row := q.db.QueryRow(ctx, GetUserByVerificationToken, value)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.EmailVerified,
		&i.Image,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const GetVerificationByIdentifier = `-- name: GetVerificationByIdentifier :one
select id, identifier, value, expires_at, created_at, updated_at
from "verification"
where identifier = $1
  and expires_at > now()
limit 1
`

func (q *Queries) GetVerificationByIdentifier(ctx context.Context, identifier string) (*Verification, error) {
	row := q.db.QueryRow(ctx, GetVerificationByIdentifier, identifier)
	var i Verification
	err := row.Scan(
		&i.ID,
		&i.Identifier,
		&i.Value,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const GetVerificationByValue = `-- name: GetVerificationByValue :one
select id, identifier, value, expires_at, created_at, updated_at
from "verification"
where value = $1
  and expires_at > now()
limit 1
`

func (q *Queries) GetVerificationByValue(ctx context.Context, value string) (*Verification, error) {
	row := q.db.QueryRow(ctx, GetVerificationByValue, value)
	var i Verification
	err := row.Scan(
		&i.ID,
		&i.Identifier,
		&i.Value,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const ListAPITokensByUser = `-- name: ListAPITokensByUser :many
select id, user_id, name, token_prefix, created_at, expires_at, last_used_at
from "api_tokens"
where user_id = $1
  and (expires_at is null or expires_at > now())
order by created_at desc
`

type ListAPITokensByUserRow struct {
	ID          pgtype.UUID        `json:"id"`
	UserID      string             `json:"user_id"`
	Name        string             `json:"name"`
	TokenPrefix string             `json:"token_prefix"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	ExpiresAt   pgtype.Timestamptz `json:"expires_at"`
	LastUsedAt  pgtype.Timestamptz `json:"last_used_at"`
}

func (q *Queries) ListAPITokensByUser(ctx context.Context, userID string) ([]*ListAPITokensByUserRow, error) {
	rows, err := q.db.Query(ctx, ListAPITokensByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListAPITokensByUserRow{}
	for rows.Next() {
		var i ListAPITokensByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.TokenPrefix,
			&i.CreatedAt,
			&i.ExpiresAt,
			&i.LastUsedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListRecentVerifications = `-- name: ListRecentVerifications :many
select id, identifier, value, expires_at, created_at, updated_at
from "verification"
where expires_at > now()
order by created_at desc
limit 10
`

func (q *Queries) ListRecentVerifications(ctx context.Context) ([]*Verification, error) {
	rows, err := q.db.Query(ctx, ListRecentVerifications)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Verification{}
	for rows.Next() {
		var i Verification
		if err := rows.Scan(
			&i.ID,
			&i.Identifier,
			&i.Value,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateAPITokenLastUsed = `-- name: UpdateAPITokenLastUsed :exec
update "api_tokens"
set last_used_at = now()
where id = $1
`

func (q *Queries) UpdateAPITokenLastUsed(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, UpdateAPITokenLastUsed, id)
	return err
}

const UpdateAPITokenName = `-- name: UpdateAPITokenName :exec
update "api_tokens"
set name = $1
where id = $2 and user_id = $3
`

type UpdateAPITokenNameParams struct {
	Name   string      `json:"name"`
	ID     pgtype.UUID `json:"id"`
	UserID string      `json:"user_id"`
}

func (q *Queries) UpdateAPITokenName(ctx context.Context, arg *UpdateAPITokenNameParams) error {
	_, err := q.db.Exec(ctx, UpdateAPITokenName, arg.Name, arg.ID, arg.UserID)
	return err
}

const UpdateUserEmailVerified = `-- name: UpdateUserEmailVerified :exec
update "user"
set email_verified = true, updated_at = now()
where id = $1
`

func (q *Queries) UpdateUserEmailVerified(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, UpdateUserEmailVerified, id)
	return err
}
