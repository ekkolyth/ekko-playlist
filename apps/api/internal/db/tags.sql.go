// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: tags.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const AddVideoTags = `-- name: AddVideoTags :exec
insert into video_tags (video_id, tag_id)
select v, t
from unnest($1::bigint[]) as v(video_id)
cross join unnest($2::bigint[]) as t(tag_id)
on conflict (video_id, tag_id) do nothing
`

type AddVideoTagsParams struct {
	Column1 []int64 `json:"column_1"`
	Column2 []int64 `json:"column_2"`
}

func (q *Queries) AddVideoTags(ctx context.Context, arg *AddVideoTagsParams) error {
	_, err := q.db.Exec(ctx, AddVideoTags, arg.Column1, arg.Column2)
	return err
}

const CreateTag = `-- name: CreateTag :one
insert into tags (user_id, name, color)
values ($1, $2, $3)
returning id, user_id, name, color, created_at, updated_at
`

type CreateTagParams struct {
	UserID string `json:"user_id"`
	Name   string `json:"name"`
	Color  string `json:"color"`
}

func (q *Queries) CreateTag(ctx context.Context, arg *CreateTagParams) (*Tag, error) {
	row := q.db.QueryRow(ctx, CreateTag, arg.UserID, arg.Name, arg.Color)
	var i Tag
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Color,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const DeleteTag = `-- name: DeleteTag :exec
delete from tags
where id = $1 and user_id = $2
`

type DeleteTagParams struct {
	ID     int64  `json:"id"`
	UserID string `json:"user_id"`
}

func (q *Queries) DeleteTag(ctx context.Context, arg *DeleteTagParams) error {
	_, err := q.db.Exec(ctx, DeleteTag, arg.ID, arg.UserID)
	return err
}

const FilterVideosByTags = `-- name: FilterVideosByTags :many
select distinct v.id, v.video_id, v.normalized_url, v.original_url, v.title, v.channel, v.user_id, v.created_at
from videos v
join video_tags vt on v.id = vt.video_id
where v.user_id = $1 and vt.tag_id = ANY($2::bigint[])
order by v.created_at desc
`

type FilterVideosByTagsParams struct {
	UserID  string  `json:"user_id"`
	Column2 []int64 `json:"column_2"`
}

func (q *Queries) FilterVideosByTags(ctx context.Context, arg *FilterVideosByTagsParams) ([]*Video, error) {
	rows, err := q.db.Query(ctx, FilterVideosByTags, arg.UserID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Video{}
	for rows.Next() {
		var i Video
		if err := rows.Scan(
			&i.ID,
			&i.VideoID,
			&i.NormalizedUrl,
			&i.OriginalUrl,
			&i.Title,
			&i.Channel,
			&i.UserID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const FilterVideosByTagsAnd = `-- name: FilterVideosByTagsAnd :many
select v.id, v.video_id, v.normalized_url, v.original_url, v.title, v.channel, v.user_id, v.created_at
from videos v
where v.user_id = $1
  and (
    select count(distinct vt.tag_id)
    from video_tags vt
    where vt.video_id = v.id
      and vt.tag_id = ANY($2::bigint[])
  ) = array_length($2::bigint[], 1)
order by v.created_at desc
`

type FilterVideosByTagsAndParams struct {
	UserID  string  `json:"user_id"`
	Column2 []int64 `json:"column_2"`
}

func (q *Queries) FilterVideosByTagsAnd(ctx context.Context, arg *FilterVideosByTagsAndParams) ([]*Video, error) {
	rows, err := q.db.Query(ctx, FilterVideosByTagsAnd, arg.UserID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Video{}
	for rows.Next() {
		var i Video
		if err := rows.Scan(
			&i.ID,
			&i.VideoID,
			&i.NormalizedUrl,
			&i.OriginalUrl,
			&i.Title,
			&i.Channel,
			&i.UserID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetTagByID = `-- name: GetTagByID :one
select id, user_id, name, color, created_at, updated_at
from tags
where id = $1 and user_id = $2
`

type GetTagByIDParams struct {
	ID     int64  `json:"id"`
	UserID string `json:"user_id"`
}

func (q *Queries) GetTagByID(ctx context.Context, arg *GetTagByIDParams) (*Tag, error) {
	row := q.db.QueryRow(ctx, GetTagByID, arg.ID, arg.UserID)
	var i Tag
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Color,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const GetVideoTags = `-- name: GetVideoTags :many
select t.id, t.user_id, t.name, t.color, t.created_at, t.updated_at
from video_tags vt
join tags t on vt.tag_id = t.id
where vt.video_id = $1
`

func (q *Queries) GetVideoTags(ctx context.Context, videoID int64) ([]*Tag, error) {
	rows, err := q.db.Query(ctx, GetVideoTags, videoID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Tag{}
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Color,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetVideoTagsForVideos = `-- name: GetVideoTagsForVideos :many
select vt.video_id, t.id as tag_id, t.name as tag_name, t.color as tag_color
from video_tags vt
join tags t on vt.tag_id = t.id
where vt.video_id = ANY($1::bigint[])
`

type GetVideoTagsForVideosRow struct {
	VideoID  int64  `json:"video_id"`
	TagID    int64  `json:"tag_id"`
	TagName  string `json:"tag_name"`
	TagColor string `json:"tag_color"`
}

func (q *Queries) GetVideoTagsForVideos(ctx context.Context, dollar_1 []int64) ([]*GetVideoTagsForVideosRow, error) {
	rows, err := q.db.Query(ctx, GetVideoTagsForVideos, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetVideoTagsForVideosRow{}
	for rows.Next() {
		var i GetVideoTagsForVideosRow
		if err := rows.Scan(
			&i.VideoID,
			&i.TagID,
			&i.TagName,
			&i.TagColor,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListTags = `-- name: ListTags :many
select id, user_id, name, color, created_at, updated_at
from tags
where user_id = $1
order by created_at desc
`

func (q *Queries) ListTags(ctx context.Context, userID string) ([]*Tag, error) {
	rows, err := q.db.Query(ctx, ListTags, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Tag{}
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Color,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListVideosWithTags = `-- name: ListVideosWithTags :many
select v.id, v.video_id, v.normalized_url, v.original_url, v.title, v.channel, v.user_id, v.created_at,
       t.id as tag_id, t.name as tag_name, t.color as tag_color
from videos v
left join video_tags vt on v.id = vt.video_id
left join tags t on vt.tag_id = t.id
where v.user_id = $1
order by v.created_at desc
`

type ListVideosWithTagsRow struct {
	ID            int64              `json:"id"`
	VideoID       string             `json:"video_id"`
	NormalizedUrl string             `json:"normalized_url"`
	OriginalUrl   string             `json:"original_url"`
	Title         string             `json:"title"`
	Channel       string             `json:"channel"`
	UserID        string             `json:"user_id"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	TagID         *int64             `json:"tag_id"`
	TagName       *string            `json:"tag_name"`
	TagColor      *string            `json:"tag_color"`
}

func (q *Queries) ListVideosWithTags(ctx context.Context, userID string) ([]*ListVideosWithTagsRow, error) {
	rows, err := q.db.Query(ctx, ListVideosWithTags, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListVideosWithTagsRow{}
	for rows.Next() {
		var i ListVideosWithTagsRow
		if err := rows.Scan(
			&i.ID,
			&i.VideoID,
			&i.NormalizedUrl,
			&i.OriginalUrl,
			&i.Title,
			&i.Channel,
			&i.UserID,
			&i.CreatedAt,
			&i.TagID,
			&i.TagName,
			&i.TagColor,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const RemoveVideoTags = `-- name: RemoveVideoTags :exec
delete from video_tags
where video_id = $1 and tag_id = ANY($2::bigint[])
`

type RemoveVideoTagsParams struct {
	VideoID int64   `json:"video_id"`
	Column2 []int64 `json:"column_2"`
}

func (q *Queries) RemoveVideoTags(ctx context.Context, arg *RemoveVideoTagsParams) error {
	_, err := q.db.Exec(ctx, RemoveVideoTags, arg.VideoID, arg.Column2)
	return err
}

const UpdateTag = `-- name: UpdateTag :one
update tags
set name = $3, color = $4, updated_at = now()
where id = $1 and user_id = $2
returning id, user_id, name, color, created_at, updated_at
`

type UpdateTagParams struct {
	ID     int64  `json:"id"`
	UserID string `json:"user_id"`
	Name   string `json:"name"`
	Color  string `json:"color"`
}

func (q *Queries) UpdateTag(ctx context.Context, arg *UpdateTagParams) (*Tag, error) {
	row := q.db.QueryRow(ctx, UpdateTag,
		arg.ID,
		arg.UserID,
		arg.Name,
		arg.Color,
	)
	var i Tag
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Color,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
